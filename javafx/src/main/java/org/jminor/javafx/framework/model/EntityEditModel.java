/*
 * Copyright (c) 2004 - 2015, Björn Darri Sigurðsson. All Rights Reserved.
 */
package org.jminor.javafx.framework.model;

import org.jminor.common.db.exception.DatabaseException;
import org.jminor.common.model.Event;
import org.jminor.common.model.EventObserver;
import org.jminor.common.model.Events;
import org.jminor.common.model.Value;
import org.jminor.common.model.valuemap.ValueChange;
import org.jminor.common.model.valuemap.exception.ValidationException;
import org.jminor.framework.db.EntityConnectionProvider;
import org.jminor.framework.domain.Entities;
import org.jminor.framework.domain.Entity;
import org.jminor.framework.domain.EntityUtil;

import javafx.collections.ObservableList;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

public class EntityEditModel {

  private final Entity entity;
  private final Map<String, Event<ValueChange<String, ?>>> valueChangeEventMap = new HashMap<>();
  private final EntityConnectionProvider connectionProvider;

  private final Event<List<Entity>> insertEvent = Events.event();
  private final Event<List<Entity>> updateEvent = Events.event();
  private final Event<List<Entity>> deleteEvent = Events.event();

  public EntityEditModel(final String entityID, final EntityConnectionProvider connectionProvider) {
    this.entity = Entities.entity(entityID);
    this.connectionProvider = connectionProvider;
    bindEvents();
  }

  public final String getEntityID() {
    return entity.getEntityID();
  }

  public final EntityConnectionProvider getConnectionProvider() {
    return connectionProvider;
  }

  public final Object setValue(final String propertyID, final Object value) {
    return entity.setValue(propertyID, value);
  }

  public final Object getValue(final String propertyID) {
    return entity.getValue(propertyID);
  }

  public final void setEntity(final Entity entity) {
    this.entity.setAs(entity);
  }

  public final Entity getEntityCopy(final boolean includePrimaryKeyValues) {
    final Entity copy = (Entity) entity.getCopy();
    if (!includePrimaryKeyValues) {
      copy.clearPrimaryKeyValues();
    }

    return copy;
  }

  public final List<Entity> insert() throws DatabaseException, ValidationException {
    final boolean includePrimaryKeyValues = !Entities.isPrimaryKeyAutoGenerated(getEntityID());
    final List<Entity> insertedEntities = connectionProvider.getConnection().selectMany(
            doInsert(Collections.singletonList(getEntityCopy(includePrimaryKeyValues))));
    if (insertedEntities.isEmpty()) {
      throw new RuntimeException("Insert did not return an entity, usually caused by a misconfigured key generator");
    }
    setEntity(insertedEntities.get(0));
    insertEvent.fire(insertedEntities);

    return insertedEntities;
  }

  public final List<Entity> insert(final List<Entity> entities) throws DatabaseException {
    Objects.requireNonNull(entities);
    if (entities.isEmpty()) {
      return Collections.emptyList();
    }
    final List<Entity> insertedEntities = connectionProvider.getConnection().selectMany(doInsert(entities));
    insertEvent.fire(insertedEntities);

    return insertedEntities;
  }

  public final Entity update() throws DatabaseException {
    final List<Entity> updated = update(Collections.singletonList(entity));
    setEntity(updated.get(0));

    return updated.get(0);
  }

  public final List<Entity> update(final List<Entity> entities) throws DatabaseException {
    Objects.requireNonNull(entities);
    final List<Entity> modified = EntityUtil.getModifiedEntities(entities);
    if (!modified.isEmpty()) {
      final List<Entity> updated = doUpdate(modified);
      updateEvent.fire(updated);

      return updated;
    }

    return entities;
  }

  public final void delete() throws DatabaseException {
    delete(Collections.singletonList(entity));
  }

  public final void delete(final List<Entity> entities) throws DatabaseException {
    Objects.requireNonNull(entities);
    if (!entities.isEmpty()) {
      doDelete(entities);
      deleteEvent.fire(entities);
    }
  }

  public ObservableList<Entity> createForeignKeyList(final String propertyID) {
    return new ObservableEntityList(Entities.getForeignKeyProperty(entity.getEntityID(),
            propertyID).getReferencedEntityID(), connectionProvider);
  }

  public final Value createValue(final String propertyID) {
    return new EntityValue<>(propertyID, this);
  }

  public final EventObserver getValueObserver(final String propertyID) {
    return getValueChangeEvent(propertyID).getObserver();
  }

  protected List<Entity.Key> doInsert(final List<Entity> entities) throws DatabaseException {
    return connectionProvider.getConnection().insert(entities);
  }

  protected List<Entity> doUpdate(final List<Entity> entities) throws DatabaseException {
    return connectionProvider.getConnection().update(entities);
  }

  protected void doDelete(final List<Entity> entities) throws DatabaseException {
    connectionProvider.getConnection().delete(EntityUtil.getPrimaryKeys(entities));
  }

  private void bindEvents() {
    entity.addValueListener(valueChange -> {
      final Event<ValueChange<String, ?>> valueChangeEvent = valueChangeEventMap.get(valueChange.getKey());
      if (valueChangeEvent != null) {
        valueChangeEvent.fire(valueChange);
      }
    });
  }

  private Event<ValueChange<String, ?>> getValueChangeEvent(final String propertyID) {
    if (!valueChangeEventMap.containsKey(propertyID)) {
      valueChangeEventMap.put(propertyID, Events.<ValueChange<String, ?>>event());
    }

    return valueChangeEventMap.get(propertyID);
  }

  private static final class EntityValue<V> implements Value<V> {

    private final String propertyID;
    private final EntityEditModel editModel;

    private EntityValue(final String propertyID, final EntityEditModel editModel) {
      this.propertyID = propertyID;
      this.editModel = editModel;
    }

    @Override
    public void set(final V value) {
      editModel.setValue(propertyID, value);
    }

    @Override
    public V get() {
      return (V) editModel.getValue(propertyID);
    }

    @Override
    public EventObserver<V> getObserver() {
      return editModel.getValueObserver(propertyID);
    }
  }
}
