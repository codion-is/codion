/*
 * Copyright (c) 2004 - 2015, Björn Darri Sigurðsson. All Rights Reserved.
 */
package org.jminor.javafx.framework.model;

import org.jminor.common.db.exception.DatabaseException;
import org.jminor.common.model.Event;
import org.jminor.common.model.EventInfoListener;
import org.jminor.common.model.EventObserver;
import org.jminor.common.model.Events;
import org.jminor.common.model.State;
import org.jminor.common.model.StateObserver;
import org.jminor.common.model.States;
import org.jminor.common.model.Value;
import org.jminor.common.model.valuemap.DefaultValueMapEditModel;
import org.jminor.common.model.valuemap.exception.ValidationException;
import org.jminor.framework.Configuration;
import org.jminor.framework.db.EntityConnectionProvider;
import org.jminor.framework.domain.Entities;
import org.jminor.framework.domain.Entity;
import org.jminor.framework.domain.EntityUtil;
import org.jminor.framework.domain.Property;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

public class EntityEditModel extends DefaultValueMapEditModel<String, Object> {

  private final EntityConnectionProvider connectionProvider;

  private final Event<InsertEvent> insertEvent = Events.event();
  private final Event<UpdateEvent> updateEvent = Events.event();
  private final Event<DeleteEvent> deleteEvent = Events.event();

  private final Event<Entity> entitySetEvent = Events.event();
  private final State entityNewState = States.state(true);

  /**
   * Contains true if values should persist for the given property when the model is cleared
   */
  private final Map<String, Boolean> persistentValues = new HashMap<>();

  public EntityEditModel(final String entityID, final EntityConnectionProvider connectionProvider) {
    this(entityID, connectionProvider, Entities.getValidator(entityID));
  }

  public EntityEditModel(final String entityID, final EntityConnectionProvider connectionProvider,
                         final Entity.Validator validator) {
    super(Entities.entity(entityID), validator);
    this.connectionProvider = connectionProvider;
    bindEvents();
  }

  public final String getEntityID() {
    return getEntity().getEntityID();
  }

  public final EntityConnectionProvider getConnectionProvider() {
    return connectionProvider;
  }

  public final StateObserver getModifiedObserver() {
    return getEntity().getModifiedObserver();
  }

  public final StateObserver getEntityNewObserver() {
    return entityNewState.getObserver();
  }

  public final void setEntity(final Entity entity) {
    this.getEntity().setAs(entity == null ? getDefaultEntity() : entity);
    entitySetEvent.fire(entity);
  }

  public final Entity getEntityCopy(final boolean includeKeyValues) {
    final Entity copy = (Entity) getEntity().getCopy();
    if (!includeKeyValues) {
      copy.clearKeyValues();
    }

    return copy;
  }

  public final void clear() {
    setEntity(null);
  }

  public final List<Entity> insert() throws DatabaseException, ValidationException {
    final boolean includePrimaryKeyValues = !Entities.isPrimaryKeyAutoGenerated(getEntityID());
    final List<Entity> insertedEntities = connectionProvider.getConnection().selectMany(
            doInsert(Collections.singletonList(getEntityCopy(includePrimaryKeyValues))));
    if (insertedEntities.isEmpty()) {
      throw new RuntimeException("Insert did not return an entity, usually caused by a misconfigured key generator");
    }
    setEntity(insertedEntities.get(0));
    insertEvent.fire(new InsertEvent(insertedEntities));

    return insertedEntities;
  }

  public final List<Entity> insert(final List<Entity> entities) throws DatabaseException {
    Objects.requireNonNull(entities);
    if (entities.isEmpty()) {
      return Collections.emptyList();
    }
    final List<Entity> insertedEntities = connectionProvider.getConnection().selectMany(doInsert(entities));
    insertEvent.fire(new InsertEvent(insertedEntities));

    return insertedEntities;
  }

  public final Entity update() throws DatabaseException {
    final List<Entity> updated = update(Collections.singletonList(getEntity()));
    setEntity(updated.get(0));

    return updated.get(0);
  }

  public final List<Entity> update(final List<Entity> entities) throws DatabaseException {
    Objects.requireNonNull(entities);
    final List<Entity> modified = EntityUtil.getModifiedEntities(entities);
    if (!modified.isEmpty()) {
      final List<Entity> updated = doUpdate(modified);
      updateEvent.fire(new UpdateEvent(EntityUtil.mapToOriginalPrimaryKey(modified, updated)));

      return updated;
    }

    return entities;
  }

  public final void delete() throws DatabaseException {
    delete(Collections.singletonList(getEntity()));
  }

  public final void delete(final List<Entity> entities) throws DatabaseException {
    Objects.requireNonNull(entities);
    if (!entities.isEmpty()) {
      doDelete(entities);
      deleteEvent.fire(new DeleteEvent(entities));
    }
  }

  public final Value createValue(final String propertyID) {
    return new EntityValue<>(propertyID, this);
  }

  public boolean isEntityNew() {
    return EntityUtil.isEntityNew(getEntity());
  }

  public final void addEntitySetListener(final EventInfoListener<Entity> listener) {
    entitySetEvent.addInfoListener(listener);
  }

  public final void addInsertListener(final EventInfoListener<InsertEvent> listener) {
    insertEvent.addInfoListener(listener);
  }

  public final void addUpdateListener(final EventInfoListener<UpdateEvent> listener) {
    updateEvent.addInfoListener(listener);
  }

  public final void addDeleteListener(final EventInfoListener<DeleteEvent> listener) {
    deleteEvent.addInfoListener(listener);
  }

  public final Entity getDefaultEntity() {
    return EntityUtil.getEntity(getEntityID(), this::getDefaultValue);
  }

  public Object getDefaultValue(final Property property) {
    return isValuePersistent(property) ? getValue(property.getPropertyID()) : property.getDefaultValue();
  }

  public boolean isValuePersistent(final Property property) {
    if (persistentValues.containsKey(property.getPropertyID())) {
      return persistentValues.get(property.getPropertyID());
    }

    return property instanceof Property.ForeignKeyProperty &&
            Configuration.getBooleanValue(Configuration.PERSIST_FOREIGN_KEY_VALUES);
  }

  public final EntityEditModel setValuePersistent(final String propertyID, final boolean persistValue) {
    persistentValues.put(propertyID, persistValue);
    return this;
  }

  protected List<Entity.Key> doInsert(final List<Entity> entities) throws DatabaseException {
    return connectionProvider.getConnection().insert(entities);
  }

  protected List<Entity> doUpdate(final List<Entity> entities) throws DatabaseException {
    return connectionProvider.getConnection().update(entities);
  }

  protected void doDelete(final List<Entity> entities) throws DatabaseException {
    connectionProvider.getConnection().delete(EntityUtil.getKeys(entities));
  }

  private Entity getEntity() {
    return (Entity) getValueMap();
  }

  private void bindEvents() {
    getValueObserver().addInfoListener(valueChange -> entityNewState.setActive(isEntityNew()));
    entitySetEvent.addInfoListener(activeEntity -> entityNewState.setActive(isEntityNew()));
  }

  public static final class InsertEvent {

    private final List<Entity> insertedEntities;

    /**
     * Instantiates a new InsertEvent.
     * @param insertedEntities the inserted entities
     */
    public InsertEvent(final List<Entity> insertedEntities) {
      this.insertedEntities = insertedEntities;
    }

    public List<Entity> getInsertedEntities() {
      return insertedEntities;
    }
  }

  public static final class DeleteEvent {

    private final List<Entity> deletedEntities;

    /**
     * Instantiates a new DeleteEvent.
     * @param deletedEntities the deleted entities
     */
    public DeleteEvent(final List<Entity> deletedEntities) {
      this.deletedEntities = deletedEntities;
    }

    public List<Entity> getDeletedEntities() {
      return deletedEntities;
    }
  }

  public static final class UpdateEvent {

    private final Map<Entity.Key, Entity> updatedEntities;

    /**
     * Instantiates a new UpdateEvent.
     * @param updatedEntities the updated entities, mapped to their respective original primary key, that is,
     * the primary key prior to the update
     */
    public UpdateEvent(final Map<Entity.Key, Entity> updatedEntities) {
      this.updatedEntities = updatedEntities;
    }

    public Map<Entity.Key, Entity> getUpdatedEntities() {
      return updatedEntities;
    }
  }

  private static final class EntityValue<V> implements Value<V> {

    private final String propertyID;
    private final EntityEditModel editModel;
    private final Event<V> valueChangeEvent = Events.event();

    private EntityValue(final String propertyID, final EntityEditModel editModel) {
      this.propertyID = propertyID;
      this.editModel = editModel;
      this.editModel.addValueListener(propertyID, valueChange -> valueChangeEvent.fire((V) valueChange.getNewValue()));
    }

    @Override
    public void set(final V value) {
      editModel.setValue(propertyID, value);
    }

    @Override
    public V get() {
      return (V) editModel.getValue(propertyID);
    }

    @Override
    public EventObserver<V> getObserver() {
      return valueChangeEvent.getObserver();
    }
  }
}
