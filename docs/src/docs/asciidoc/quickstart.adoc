= Quickstart
:docinfo: shared-head
:dir-source: ../../../../demos/manual/src/main/java
:dir-source-sql: ../../../../demos/manual/src/main/sql

== Rich client
JMinor is primarily a Swing based framework, the Swing client is mature and stable while the JavaFX client is quite rudimentary and still in the 'proof-of-concept' stage. The below artifacts pull in all required framework dependencies.

[cols="1,4"]
|===
|Client|Artifact

|Swing|org.jminor.{jminor-jdk}:jminor-swing-framework.ui:{jminor-version}
|JavaFX|org.jminor.{jminor-jdk}:jminor-javafx-framework:{jminor-version}
|===

== Database connectivity
A JMinor client has three ways of connecting to a database, directly via a local JDBC connection or remotely via RMI or HTTP using the JMinor remote server.

[cols="1,4"]
|===
|DB Connection|Artifact

|Local|org.jminor.{jminor-jdk}:jminor-framework-db-local:{jminor-version}
|RMI|org.jminor.{jminor-jdk}:jminor-framework-db-remote:{jminor-version}
|HTTP|org.jminor.{jminor-jdk}:jminor-framework-db-http:{jminor-version}
|===

== DBMS
When connecting to the database with a local JDBC connection the DBMS module for the underlying database must be on the classpath. Note that these artifacts do not depend on the JDBC drivers, so those must be added separately.

The most used and tested DBMS modules are:

1. Oracle
2. H2 Database
3. Postgresql

[cols="1,4"]
|===
|DBMS|Artifact

|Derby|org.jminor.{jminor-jdk}:jminor-dbms-derby:{jminor-version}
|H2 Database|org.jminor.{jminor-jdk}:jminor-dbms-h2database:{jminor-version}
|HSQL|org.jminor.{jminor-jdk}:jminor-dbms-hsql:{jminor-version}
|MySQL|org.jminor.{jminor-jdk}:jminor-dbms-mysql:{jminor-version}
|Oracle|org.jminor.{jminor-jdk}:jminor-dbms-oracle:{jminor-version}
|Postgresql|org.jminor.{jminor-jdk}:jminor-dbms-postgresql:{jminor-version}
|SQLite|org.jminor.{jminor-jdk}:jminor-dbms-sqlite:{jminor-version}
|SQL Server|org.jminor.{jminor-jdk}:jminor-dbms-sqlserver:{jminor-version}
|===

== Logging
JMinor uses SLF4J throughout so all you need to do is add a SLF4J bridge for your logging framework of choice to the classpath. If you use Logback or Log4J you can use one of the logging-proxy plugins below which will pull in the required dependencies and provide a main-menu action in the client for setting the logging level.

[cols="1,4"]
|===
|Logging|Artifact

|Logback|org.jminor.{jminor-jdk}:jminor-plugin-logback-proxy:{jminor-version}
|Log4j|org.jminor.{jminor-jdk}:jminor-plugin-log4j-proxy:{jminor-version}
|Java Util Logging|org.jminor.{jminor-jdk}:jminor-plugin-jul-proxy:{jminor-version}
|===

== Gradle
[source,groovy,subs=attributes]
----
dependencies {
    //Swing client UI module
    implementation 'org.jminor.{jminor-jdk}:jminor-swing-framework-ui:{jminor-version}'

    //JSON for persisting client preferences
    runtimeOnly 'org.jminor.{jminor-jdk}:jminor-plugin-json:{jminor-version}'
    //Local JDBC connection module
    runtimeOnly 'org.jminor.{jminor-jdk}:jminor-framework-db-local:{jminor-version}'
    //H2 DBMS module
    runtimeOnly 'org.jminor.{jminor-jdk}:jminor-dbms-h2database:{jminor-version}'
    //H2 JDBC driver
    runtimeOnly 'com.h2database:h2:1.4.200'
    //Logging with Logback
    runtimeOnly 'org.jminor.{jminor-jdk}:jminor-plugin-logback-proxy:{jminor-version}'

    //Domain model unit testing module
    testImplementation 'org.jminor.{jminor-jdk}:jminor-framework-domain-test:{jminor-version}'
    //JUnit 5
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.6.0'
}
----

== Code examples

=== Domain model

The JMinor framework is based around the *Entity* class, a map-like structure, representing a row in a table. The domain is modelled much like an E/R diagram, with an *EntityDefinition* per table, a *Property* for each column and a *ForeignKeyProperty* for each foreign key relationship.

[cols="2,4"]
|===
|Modules|Artifacts
|org.jminor.framework.domain|org.jminor.{jminor-jdk}:jminor-framework-domain:{jminor-version}
|===

==== Defining entities

The below examples are somewhat simplified, but functionally correct.

.View example schema SQL
[%collapsible]
====

NOTE: Not all columns are used in the example code below.

[source,sql,indent=0]
----
include::{dir-source-sql}/create_schema.sql[]
----
====

First we define a entity based on the table *store.customer*, using String constants to identify the entity type (the *entityId*) and its properties (*propertyIds*).

NOTE: In this example the constants contain the actual table and column names, but these can be specified via parameters if that is preferred (see manual).

[source,java,indent=0]
----
include::{dir-source}/org/jminor/framework/demos/manual/quickstart/Example.java[tags=customer]
----

Next we define a entity based on the table *store.address*.

[source,java,indent=0]
----
include::{dir-source}/org/jminor/framework/demos/manual/quickstart/Example.java[tags=address]
----

And finally we define a entity based on the _many-to-many_ relationship table *store.customer_address*.

[source,java,indent=0]
----
include::{dir-source}/org/jminor/framework/demos/manual/quickstart/Example.java[tags=customerAddress]
----

=== Swing UI

The *EntityPanel* class provides a Swing UI for viewing and editing entities. It is composed of a *EntityEditPanel* and a *EntityTablePanel*. For each of these panel classes there is a corresponding model class; *SwingEntityModel*, which is composed of a *SwingEntityEditModel* and a *SwingEntityTableModel*. The only class you are required to extend is the *EntityEditPanel*, which provides the input controls for editing a entity.

[cols="2,4"]
|===
|Modules|Artifacts
|org.jminor.swing.framework.ui|org.jminor.{jminor-jdk}:jminor-swing-framework-ui:{jminor-version}
|===

==== Master panel

Here we extend a *EntityEditPanel* to provide the UI for editing a customer and use that edit panel class when we assemble the *EntityPanel*. We use a default *SwingEntityModel* implementation, which internally, creates a default *SwingEnitityEditModel* and *SwingEntityTableModel*.

[source,java,indent=0]
----
include::{dir-source}/org/jminor/framework/demos/manual/quickstart/Example.java[tags=customerPanel]
----

==== Detail panel

Here we create a panel for viewing and editing customer addresses, much like the one above. We start by creating a default *SwingEntityModel* instance, which we add as a detail model on the customer model. Finally, we create a *EntityPanel* for the customer address and add that as a detail panel on the customer panel.

[source,java,indent=0]
----
include::{dir-source}/org/jminor/framework/demos/manual/quickstart/Example.java[tags=detailPanel]
----

=== Domain model unit testi

[source,java,indent=0]
----
include::{dir-source}/org/jminor/framework/demos/manual/quickstart/Example.java[tags=domainModelTest]
----

=== EntityConnection

The *EntityConnection* interface provides select, insert, update, and delete methods. It has a few implementations, such as the one used below, which is based on a local JDBC connection.

[cols="2,4,2"]
|===
|Modules|Artifacts|Description
|org.jminor.framework.db.core|org.jminor.{jminor-jdk}:jminor-framework-db-core:{jminor-version}|Database API
|org.jminor.framework.db.local|org.jminor.{jminor-jdk}:jminor-framework-db-local:{jminor-version}|Local JDBC
|===

==== Selecting

[source,java,indent=0]
----
include::{dir-source}/org/jminor/framework/demos/manual/quickstart/Example.java[tags=select]
----

==== Persisting

[source,java,indent=0]
----
include::{dir-source}/org/jminor/framework/demos/manual/quickstart/Example.java[tags=persist]
----

.Full code
[%collapsible]
====
[source,java,indent=0]
----
include::{dir-source}/org/jminor/framework/demos/manual/quickstart/Example.java[]
----
====