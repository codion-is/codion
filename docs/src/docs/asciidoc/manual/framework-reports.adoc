= Reporting with JasperReports
:dir-source: ../../../../../demos/manual/src/main/java
:dir-tutorials: ../tutorials
:url-javadoc: link:../api

JMinor uses a plugin oriented approach to report viewing, and provides an implementation for JasperReports and NextReports.

With the JMinor JasperReports plugin you can either design your report based on a SQL query in which case you use the JasperReportsWrapper class, which facilitates the report being filled using the active database connection or you can design your report around the JRDataSource implementation provided by the {url-javadoc}/org/jminor/plugin/jasperreports/model/JasperReportsEntityDataSource.html[JasperReportsEntityDataSource] class, which is constructed around an iterator.

== JDBC Reports

Using a report based on a SQL query, {url-javadoc}/org/jminor/plugin/jasperreports/model/JasperReportsWrapper.html[JasperReportsWrapper] and {url-javadoc}/org/jminor/plugin/jasperreports/ui/JasperReportsUIWrapper.html[JasperReportsUIWrapper] is the simplest way of viewing a report using JMinor, just add a method similar to the one below to a EntityPanel subclass. You can then create an action calling that method and put it in for example the table popup menu as described in the <<entity-panel.adoc#_adding_a_print_action, adding a print action>> section.

[source,java,indent=0]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/ui/CustomerTablePanel.java[tags=customerTablePanel]
----

== JRDataSource Reports

The JRDataSource implementation provided by the JasperReportsEntityDataSource simply iterates through the iterator received via the constructor and retrieves the field values from the underlying entities. For this to work you must design the report using field names that correspond to the property IDs, so using the Store domain example from above the fields in a report showing the available items would have to be named 'name', 'is_active', 'category_code' etc. If you need to use a field that does not correspond to a property in the underlying entity, i.e. when combining two fields into one you must override the __getFieldValue()__ method and handle that special case there.

[source,java]
----
@Override
public Object getFieldValue(JRField jrField) {
  if (jrField.getName().equals("name_category_code") {
    Entity currentRecord = getCurrentEntity();

    return currentRecord.getString(Store.ITEM_NAME) + " - "
             + currentRecord.getAsString(Store.ITEM_CATEGORY_CODE);
  }

  return super.getFieldValue(jrField);
}
----

== Examples

* <<{dir-tutorials}/empdept.adoc#_ui, EmpDept UI layer>>