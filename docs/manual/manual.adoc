= Manual
:toclevels: 4
:dir-tutorials: ../tutorials
:dir-source: ../../demos/manual/src/main/java
:dir-source-world: ../../demos/world/src/main/java
:dir-source-petstore: ../../demos/petstore/src/main/java
:url-javadoc: https://heima.hafro.is/~darri/jminor_wiki_data/project/docs/api

NOTE: The code used throughout this manual is available in the 'manual' demo module included in the project.

== The basics

=== Common classes

Two common classes used throughout the framework are the {url-javadoc}/org/jminor/common/Event.html[Event] and {url-javadoc}/org/jminor/common/State.html[State] classes, their respective observers {url-javadoc}/org/jminor/common/EventObserver.html[EventObserver] and {url-javadoc}/org/jminor/common/StateObserver.html[StateObserver] and listeners {url-javadoc}/org/jminor/common/EventListener.html[EventListener] and {url-javadoc}/org/jminor/common/EventDataListener.html[EventDataListener].

=== Event ===

The {url-javadoc}/org/jminor/common/Event.html[Event] class is a simple event implementation used throughout the framework to signal object state changes or to indicate that an action is about to start or has ended. Classes typically publish their events via public *addListener* methods. Events are triggered by calling the *fire()* method, with or without a *data* parameter.

Events are instantiated via the {url-javadoc}/org/jminor/common/Events.html[Events] factory class.

To listen to Events you use the {url-javadoc}/org/jminor/common/EventListener.html[EventListener] or {url-javadoc}/org/jminor/common/EventDataListener.html[EventDataListener] interfaces.

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/basics/EventState.java[tags=event]
----

=== State ===

The {url-javadoc}/org/jminor/common/State.html[State] class encapsulates a boolean state and provides read only access and a change observer via {url-javadoc}/org/jminor/common/StateObserver.html[StateObserver].

States are instantiated via the {url-javadoc}/org/jminor/common/States.html[States] factory class.

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/basics/EventState.java[tags=state]
----

Any *Action* object can be linked to a *State* object via the *UiUtil.linkToEnabledState* method, where the action's *enabled* status is synchronized with the state.

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/basics/EventState.java[tags=action]
----

== Domain Model

The domain model is based around two interfaces, {url-javadoc}/org/jminor/framework/domain/Entity.html[org.jminor.framework.domain.Entity], which represents a row in a table, and {url-javadoc}/org/jminor/framework/domain/property/Property.html[org.jminor.framework.domain.property.Property], which represents columns. The
{url-javadoc}/org/jminor/framework/domain/Domain.html[org.jminor.framework.domain.Domain] class serves as a container for the domain model and as a factory for Entity and Entity.Key objects.

=== Entities

A row in a table is represented by the Entity class, a map like structure, which maps column values to the property representing each column. Each table is represented by a single entity type, identified by a *entityId*, a String unique within the domain.

NOTE: Typically the *entityId* constant contains the underlying table name, but you can use whatever identifying string you want and specify the table name via a *tableName* parameter when defining the entity.

=== Properties

Each column in a table is represented by the {url-javadoc}/org/jminor/framework/domain/property/Property.html[Property] class or one of its subclasses. The {url-javadoc}/org/jminor/framework/domain/property/Properties.html[Properties] class provides factory methods for constructing Property objects and is usually statically imported, as will be assumed in the following examples. Each Property is identified by a *propertyId*, a String, unique within the Entity.

NOTE: Typically the *propertyId* contains the underlying column name, but as with the *entityId* you can use whatever value you want and specify the column name via *setColumnName()* when instantiating the Property.

==== Example

String constants for the Entities and Properties in the World demo, here the *entityIds* have a *T_* prefix (for __Type__ or __Table__) whereas the *propertyIds* are prefixed by their respective table names.

[source,java]
----
include::{dir-source-world}/org/jminor/framework/demos/world/domain/World.java[tags=entityAndPropertyIds]
----

==== Supported data types

JMinor supports the following column data types:

* Integer (java.sql.Types.INTEGER)
* Double (java.sql.Types.DOUBLE)
* Long (java.sql.Types.BIGINT)
* BigDecimal (java.sql.Types.DECIMAL)
* LocalDateTime (java.sql.Types.TIMESTAMP)
* LocalDate (java.sql.Types.DATE)
* LocalTime (java.sql.Types.TIME)
* String (java.sql.Types.VARCHAR)
* Boolean (java.sql.Types.BOOLEAN)
* Character (java.sql.Types.CHAR)
* Blob (java.sql.Types.BLOB)

==== Property

{url-javadoc}/org/jminor/framework/domain/property/Property.html[Property] and its subclasses are used to represent entity properties, these can be transient or based on table columns.

==== Primary key

Entities must have at least one primary key column property.

The only requirement is that the primary key properties represent a unique column combination for the underlying table, it does not have to correspond to an actual table primary key, although that is of course preferable. The framework does not enforce uniqueness for these properties, so a unique or primary key on the corresponding table columns is strongly recommended.

[source,java,indent=0]
----
include::{dir-source-world}/org/jminor/framework/demos/world/domain/World.java[tags=primaryKey]
----

In case of composite primary keys you create a ColumnProperty and specify the primary key index. Note that in the example below the column with primary key index 0 is a foreign key column and wrapped in a foreignKeyProperty(), which are discussed a bit later.

[source,java,indent=0]
----
include::{dir-source-world}/org/jminor/framework/demos/world/domain/World.java[tags=compositePrimaryKey]
----

==== ColumnProperty

{url-javadoc}/org/jminor/framework/domain/property/ColumnProperty.html[ColumnProperty] is used to represent properties that are based on table columns.

[source,java,indent=0]
----
include::{dir-source-world}/org/jminor/framework/demos/world/domain/World.java[tags=columnProperty]
----

==== ForeignKeyProperty

{url-javadoc}/org/jminor/framework/domain/property/ForeignKeyProperty.html[ForeignKeyProperty] is a wrapper property used to indicate a foreign key relation. These foreign keys refer to the primary key of the referenced entity and must be constructed accordingly in case of composite primary keys.

[source,java,indent=0]
----
include::{dir-source-world}/org/jminor/framework/demos/world/domain/World.java[tags=foreignKeyPropertyCapital]
----

Referring to an entity with composite primary key.

NOTE: The order of the properties must be the same as the order of the respective primary key properties in the referenced entity.

[source,java]
----
foreignKeyProperty(MASTER_FK, "Master", T_MASTER,
        asList(
                columnProperty(MASTER_ID_1),
                columnProperty(MASTER_ID_2)
        ));
----

The above assumes the below master definition.

[source,java]
----
define(T_MASTER,
    columnProperty(ID_1).setPrimaryKeyIndex(0),
    columnProperty(ID_2).setPrimaryKeyIndex(1)
    ...
);
----

==== Boolean Properties

For databases supporting *Types.BOOLEAN* you simply use *Properties.columnProperty*.

[source,java,indent=0]
----
include::{dir-source-world}/org/jminor/framework/demos/world/domain/World.java[tags=booleanProperty]
----

For databases lacking native boolean support we use the *Properties.booleanProperty* method, specifying the underlying true/false values.

[source,java]
----
booleanProperty(CUSTOMER_IS_ACTIVE, Types.INTEGER, "Is active", 1, 0)
----

For boolean columns using unconventional types you can specify the true and false values.

[source,java]
----
booleanProperty(CUSTOMER_IS_ACTIVE, Types.VARCHAR, "Is active", "true", "false")
----

[source,java]
----
booleanProperty(CUSTOMER_IS_ACTIVE, Types.CHAR, "Is active", 'T', 'F')
----

Note that boolean properties always use the boolean Java type, the framework handles translating to and from the actual column values.
[source,java]
----
entity.put(CUSTOMER_IS_ACTIVE, true);

boolean isActive = entity.getBoolean(CUSTOMER_IS_ACTIVE);
----

==== DenormalizedViewProperty

An entity can include a property value from a entity referenced via foreign key, by defining a denormalized view property.

[source,java,indent=0]
----
include::{dir-source-world}/org/jminor/framework/demos/world/domain/World.java[tags=denormalizedViewProperty]
----

==== DenormalizedProperty

{url-javadoc}/org/jminor/framework/domain/property/DenormalizedProperty.html[DenormalizedProperty] is used for columns that should automatically get their value from a column in a referenced table. This property automatically gets the value from the column in the referenced table when the corresponding reference property value is set.
[source,java]
----
denormalizedProperty(CUSTOMER_CITY, CUSTOMER_ADDRESS_FK,
        getProperty(T_ADDRESS, ADDRESS_CITY), "City")
----

NOTE: The property is not kept in sync if the denormalized property is updated in the referenced entity.

[source,java]
----
Domain domain = getDomain();
Entity address = domain.entity(T_ADDRESS);
address.put(ADDRESS_CITY, "Syracuse");

Entity customer = domain.entity(T_CUSTOMER);
customer.put(CUSTOMER_ADDRESS_FK, address);

customer.get(CUSTOMER_CITY);//returns "Syracuse"

//NB
address.put(ADDRESS_CITY, "Canastota");
customer.get(CUSTOMER_CITY, still returns "Syracuse"

customer.put(CUSTOMER_ADDRESS_FK, address);//set the referenced value again
customer.get(CUSTOMER_CITY);//now this returns "Canastota"
----

==== SubqueryProperty

{url-javadoc}/org/jminor/framework/domain/property/SubqueryProperty.html[SubqueryProperty] is used to represent properties which get their value from a subquery returning a single value. Note that in the example below __reference_id__ must be available when the query is run, that is, the entity must include that column as a property.
[source,java]
----
Properties.subqueryProperty(SUBQUERY_PROPERTY_ID, Types.VARCHAR, "Caption",
        "select field from schema.table where id = reference_id"))
----

==== TransientProperty

{url-javadoc}/org/jminor/framework/domain/property/TransientProperty.html[TransientProperty] is used to represent a property which is not based on an underlying column, these properties all have a default value of null and can be set and retrieved just like normal properties.

==== DerivedProperty

{url-javadoc}/org/jminor/framework/domain/property/DerivedProperty.html[DerivedProperty] is used to represent a transient property which value is derived from one or more properties in the same entity. The value of a derived property is provided via a {url-javadoc}/org/jminor/framework/domain/property/DerivedProperty.Provider.html[DerivedProperty.Provider] implementation as shown below.

[source,java,indent=0]
----
include::{dir-source-world}/org/jminor/framework/demos/world/domain/World.java[tags=derivedProperty]
----

=== Domain

Each entity type is defined by calling {url-javadoc}/org/jminor/framework/domain/Domain.html#define-java.lang.String-org.jminor.framework.domain.property.Property.Builder...-[Domain.define] for each entity. The framework assumes the *entityId* is the table name, unless the *tableName* parameter is specified.

[source,java,indent=0]
----
include::{dir-source-world}/org/jminor/framework/demos/world/domain/World.java[tags=defineCity]
----

==== Examples
* <<{dir-tutorials}/world.adoc#_domain_model, World domain model>>
* <<{dir-tutorials}/empdept.adoc#_domain_model, EmpDept domain model>>
* <<{dir-tutorials}/chinook.adoc#_domain_model, Chinook domain model>>
* <<{dir-tutorials}/petstore.adoc#_domain_model, Petstore domain model>>

=== Entity.KeyProvider

The framework provides implementations for most common primary key generation strategies, sequence (with or without trigger) and auto-increment columns.

==== Auto-increment

This assumes the underlying primary key column is either an auto-increment column or is populated from a sequence using a trigger during insert.
For auto-increment columns the **valueSource** parameter should be the table name and for a sequence/trigger it should be the sequence name.

[source,java]
----
//Auto increment column in the 'store.customer' table
define(Store.T_CUSTOMER
    primaryKeyProperty(Store.CUSTOMER_ID)
    ...
).setKeyGenerator(automaticKeyGenerator("store.customer"));

//Trigger and sequence named 'store.customer_seq'
define(Store.T_CUSTOMER
    primaryKeyProperty(Store.CUSTOMER_ID)
    ...
).setKeyGenerator(automaticKeyGenerator("store.customer_seq"));
----

==== Sequence

When sequences are used without triggers the framework can fetch the value from a sequence before insert.

[source,java]
----
//Sequence named 'store.customer_seq' without a trigger
define(Store.T_CUSTOMER
    primaryKeyProperty(Store.CUSTOMER_ID)
    ...
).setKeyGenerator(sequenceKeyGenerator("store.customer_seq"));
----

==== Queried

The framework can select new primary key values from a query.

[source,java]
----
//Using a query returning the new value
define(Store.T_CUSTOMER
    primaryKeyProperty(Store.CUSTOMER_ID)
    ...
).setKeyGenerator(queriedKeyGenerator(
    "select new_id
     from store.id_values
     where table_name = 'store.customer'"));
----

==== Increment

The framework can automatically increment the primary key value by selecting the maximum value and add one, this is very simplistic, not transaction safe and is not recommended for use anywhere but the simplest demos.

[source,java]
----
define(Store.T_CUSTOMER
    primaryKeyProperty(Store.CUSTOMER_ID)
    ...
).setKeyGenerator(incrementKeyGenerator("store.customer_seq"));
----

==== Custom

You can provide a custom key generator strategy by implementing a {url-javadoc}/org/jminor/framework/domain/Entity.KeyGenerator.html[KeyGenerator].

=== Domain.StringProvider

The {url-javadoc}/org/jminor/framework/domain/Domain.StringProvider.html[Domain.StringProvider] class is for providing __toString()__ implementations for entities. This value is f. ex. used when entties are displayed in a ComboBox or as a foreign key values in table views.

[source,java]
----
define(Store.T_CUSTOMER
...
).setStringProvider(
    new StringProvider(Store.CUSTOMER_LAST_NAME)
        .addText(", ")
        .addValue(Store.CUSTOMER_FIRST_NAME)));
----

For more complex toString() implementations you can implement a custom {url-javadoc}/org/jminor/framework/domain/Entity.ToString.html[Entity.ToString].

[source,java]
----
define(Store.T_CUSTOMER
...
).setStringProvider(customer -> {
    StringBuilder builder =
       new StringBuilder(customer.getString(CUSTOMER_LASTNAME))
    .append(", ").append(customer.getString(CUSTOMER_LASTNAME));

    if (customer.isNotNull(CUSTOMER_EMAIL)) {
        builder.append(" <")
        .append(customer.getString(CUSTOMER_EMAIL))
        .append(">");
    }

    return builder.toString();
});
----

=== Validation

Custom validation of Entities is done by implementing a {url-javadoc}/org/jminor/framework/domain/Domain.Validator.html[Domain.Validator].

The default *Entity.Validator* implementation provides basic range and null validation and can be extended to provide further validations. Note that validation is performed quite often so it should not perform expensive operations. Validation requiring database access f.ex. belongs in the application model or ui.

[source,java]
----
define("entityID",
...
).setValidator(new Domain.Validator() {
      @Override
    public void validate(Entity entity, Property property)
        throws ValidationException {
        super.validate(entity, property);

        Object value = entity.get(property);

        if (!isValid(value)) {
          throw new ValidationException(property.getPropertyId(),
              value, value + " is invalid");
        }
    }
});
----

{url-javadoc}/org/jminor/framework/domain/Entity.ColorProvider.html[Entity.ColorProvider]

Provides the background color for entity property cells when displayed in a table.

[source,java]
----
define("entityId",
...
).setColorProvider(new Entity.ColorProvider() {
    public Object getColor(Entity entity, Property property) {
        if (property.is("colorPropertyId") && entity.getString("colorPropertyId").equals("CYAN")) {
          return Color.CYAN;
        }

        return null;
    }
});
----

==== Examples

* <<{dir-tutorials}/empdept.adoc#_domain_model, EmpDept domain model>>

=== Entities in action

Using the Entity class is rather straight forward.

[source,java]
----
include::{dir-source-petstore}/org/jminor/framework/demos/petstore/manual/EntitiesInAction.java[tags=entitiesInAction]
----

==== Examples

* <<{dir-tutorials}/empdept.adoc#_domain_model, EmpDept domain model>>
* <<{dir-tutorials}/chinook.adoc#_domain_model, Chinook domain model>>
* <<{dir-tutorials}/petstore.adoc#_domain_model, Petstore domain model>>

== Domain Model Unit Testing

=== Introduction

To unit test the CRUD operations on the domain model extend {url-javadoc}/org/jminor/framework/domain/test/EntityTestUnit.html[EntityTestUnit].

The unit tests are run within a single transaction which is rolled back after the test finishes, so these tests are pretty much guaranteed to leave no junk data behind.

=== EntityTestUnit

The following methods all have default implementations which are based on randomly created property values, based on the constraints set in the domain model, override if the default ones are not working.

* {url-javadoc}/org/jminor/framework/domain/test/EntityTestUnit.html#initializeReferenceEntity-java.lang.String-java.util.Map-[initializeReferenceEntity] should initialize return an instance of the given entity type to use for a foreign key reference required for inserting the entity being tested.
* {url-javadoc}/org/jminor/framework/domain/test/EntityTestUnit.html#initializeTestEntity-java.lang.String-java.util.Map-[initializeTestEntity] should return a entity to use as basis for the unit test, that is, the entity that should be inserted, selected, updated and finally deleted.
* {url-javadoc}/org/jminor/framework/domain/test/EntityTestUnit.html#modifyEntity-org.jminor.framework.domain.Entity-java.util.Map-[modifyEntity] should simply leave the entity in a modified state so that it can be used for update test, since the db layer throws an exception if an unmodified entity is updated. If *modifyEntity* returns an unmodified entity, the update test is skipped.

To run the full CRUD test for a domain entity you need to call the __testEntity(String entityId)__ method with the id of the given entity as parameter. You can either create a single __testDomain()__ method and call the __testEntity__ method in turn for each entityId or create a single __testEntityName__ for each domain entity, as we do in the example below.

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/domain/StoreTest.java[lines=13..-1]
----

==== Examples ====

* <<{dir-tutorials}/empdept.adoc#_domain_model_unit_test, EmpDept domain model test>>
* <<{dir-tutorials}/chinook.adoc#_domain_model_unit_test, Chinook domain model test>>
* <<{dir-tutorials}/petstore.adoc#_domain_model_unit_test, Petstore domain model test>>

== EntityModel

=== Introduction

The {url-javadoc}/org/jminor/framework/model/EntityEditModel.html[EntityEditModel] interface defines the CRUD business logic used by the {url-javadoc}/org/jminor/swing/framework/ui/EntityEditPanel.html[EntityEditPanel] class when entities are being edited, and must be defined for each entity requiring a CRUD user interface. The EntityEditModel works with a single entity instance, called the active entity, which can be set via the {url-javadoc}/org/jminor/framework/model/EntityEditModel.html#setEntity-org.jminor.framework.domain.Entity-[setEntity(Entity entity)] method and retrieved via {url-javadoc}/org/jminor/framework/model/EntityEditModel.html#getEntityCopy--[getEntityCopy()]. The EntityEditModel interface exposes a number of methods for manipulating as well as querying the property values of the active entity, via the {url-javadoc}/org/jminor/common/model/valuemap/ValueMapEditModel.html[ValueMapEditModel] interface which it extends

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/model/AddressModel.java[lines=9..-1]
----

=== Detail models

Directly adding a detail models is a trivial matter, the framework handles everything as long as the master/detail relationship is defined in the domain model. See link:#_entityapplicationmodel[EntityApplicationModel].

=== Table model

Each {url-javadoc}/org/jminor/framework/model/EntityModel.html[EntityModel] can contain a single {url-javadoc}/org/jminor/framework/model/EntityTableModel.html[EntityTableModel] instance. This table model can be created automatically by the **EntityModel** or supplied via a constructor argument in case of a specialized implementation.

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/model/CustomerTableModel.java[lines=10..-1]
----

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/model/AddressTableModel.java[lines=10..-1]
----

=== Edit model

Each {url-javadoc}/org/jminor/framework/model/EntityModel.html[EntityModel] contains a single {url-javadoc}/org/jminor/framework/model/EntityEditModel.html[EntityEditModel] instance. This edit model can be created automatically by the __EntityModel__ or supplied via a constructor argument in case of a specialized implementation.

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/model/CustomerEditModel.java[lines=10..-1]
----

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/model/AddressEditModel.java[lines=10..-1]
----

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/Misc.java[lines=20..53]
----

=== Event binding

The EntityModel, EntityEditModel and EntityTableModel classes expose a number of *addListener* methods.

The following example prints, to the standard output, all changes made to a given property as well as a message indicating that a refresh has started.

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/model/CustomerModel.java[lines=18..29]
----

=== Examples
* <<{dir-tutorials}/empdept.adoc#_application_model_layer, EmpDept entity models>>

== EntityApplicationModel

=== Introduction

The EntityApplicationModel class serves as the base for the application. Its main purpose is to hold references to the root EntityModel instances used by the application.

When implementing this class you must provide a constructor taking a single EntityConnectionProvider instance as argument, as seen below.

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/model/StoreAppModel.java[lines=10..-1]
----

== Application load testing

=== Introduction

The application load testing harness is used to see how your application, server and database handle multiple concurrent users. This is done by extending the abstract class {url-javadoc}/org/jminor/swing/framework/tools/EntityLoadTestModel.html[EntityLoadTestModel].

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/test/StoreLoadTest.java[lines=17..-1]
----

=== Examples

* <<{dir-tutorials}/empdept.adoc#_application_load_test, EmpDept application load test>>
* <<{dir-tutorials}/chinook.adoc#_application_load_test, Chinook application load test>>
* <<{dir-tutorials}/petstore.adoc#_application_load_test, Petstore application load test>>

== EntityPanel

=== Introduction

The {url-javadoc}/org/jminor/swing/framework/ui/EntityPanel.html[EntityPanel] is the base UI class for working with entity instances. It usually consists of an {url-javadoc}/org/jminor/swing/framework/ui/EntityTablePanel.html[EntityTablePanel], an {url-javadoc}/org/jminor/swing/framework/ui/EntityEditPanel.html[EntityEditPanel], which contains the controls (text fields, combo boxes and such) for editing an entity instance and a set of detail panels representing the entities having a master/detail relationship with the underlying entity.

==== EntityEditPanel

When instantiating an EntityPanel you can supply an EntityEditPanel instance as a parameter. When implementing an EntityEditPanel you must implement the __initializeUI()__ method, in which you should initialize the edit panel UI. The EntityEditPanel class exposes methods for creating input components and binding them with the underlying EntityEditModel instance.

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/ui/CustomerEditPanel.java[lines=12..-1]
----

=== Detail panels

Adding a detail panel is done with a single method call, but note that the underlying EntityModel must contain the correct detail model for the detail panel, in this case a *CustomerModel* instance, see <<Detail models, detail models>>. See link:#_entityapplicationpanel[EntityApplicationPanel].

=== Custom actions
The action mechanism used throughout the JMinor framework is based on the {url-javadoc}/org/jminor/swing/common/ui/control/Control.html[Control] class and its subclasses and the {url-javadoc}/org/jminor/swing/common/ui/control/ControlSet.html[ControlSet] class which, as the name suggests, represents a set of controls. There are two static utility classes for creating and presenting controls, {url-javadoc}/org/jminor/swing/common/ui/control/Controls.html[Controls] and {url-javadoc}/org/jminor/swing/common/ui/control/ControlProvider.html[ControlProvider] respectively.

=== Adding a print action ===

The most common place to add a custom control is the table popup menu, f.ex. an action for printing reports. The table popup menu is based on the ControlSet returned by the **getTablePopupControlSet()** method in the EntityPanel class which in turn uses the ControlSet returned by the **getPrintControls()** method in the same class for constructing the print popup submenu. So, to add a custom print action you override the **getPrintControls()** method and return a ControlSet containing the action.

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/ui/CustomerTablePanel.java[lines=22..40]
     //see below
include::{dir-source}/org/jminor/framework/demos/manual/store/ui/CustomerTablePanel.java[lines=54..55]
----

== EntityApplicationPanel

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/ui/StoreAppPanel.java[lines=17..-1]
----

=== Examples

* <<{dir-tutorials}/empdept.adoc#_main_application_panel, EmpDept application panel>>
* <<{dir-tutorials}/chinook.adoc#_main_application_panel, Chinook application panel>>
* <<{dir-tutorials}/petstore.adoc#_main_application_panel, Petstore application panel>>

== Reporting with JasperReports

=== Introduction

JMinor uses a plugin oriented approach to report viewing, and provides an implementation for JasperReports and NextReports.

With the JMinor JasperReports plugin you can either design your report based on a SQL query in which case you use the JasperReportsWrapper class, which facilitates the report being filled using the active database connection or you can design your report around the JRDataSource implementation provided by the {url-javadoc}/org/jminor/plugin/jasperreports/model/JasperReportsEntityDataSource.html[JasperReportsEntityDataSource] class, which is constructed around an iterator.

The EntityPanel class provides straight forward methods for viewing reports using methods provided by the EntityModel class for filling them. Both these classes rely on static utility classes for doing the actual work so you are not bound by the EntityPanel and EntityModel classes for viewing reports, they simply provide the easiest way of doing so.

=== JDBC Reports

Using a report based on a SQL query, {url-javadoc}/org/jminor/plugin/jasperreports/model/JasperReportsWrapper.html[JasperReportsWrapper] and {url-javadoc}/org/jminor/plugin/jasperreports/ui/JasperReportsUIWrapper.html[JasperReportsUIWrapper] is the simplest way of viewing a report using JMinor, just add a method similar to the one below to a EntityPanel subclass. You can then create an action calling that method and put it in for example the table popup menu as described in the <<Adding a print action, adding a print action>> section.

[source,java]
----
include::{dir-source}/org/jminor/framework/demos/manual/store/ui/CustomerTablePanel.java[lines=40..55]
----

=== JRDataSource Reports

The JRDataSource implementation provided by the JasperReportsEntityDataSource simply iterates through the iterator received via the constructor and retrieves the field values from the underlying entities. For this to work you must design the report using field names that correspond to the property IDs, so using the Store domain example from above the fields in a report showing the available items would have to be named 'name', 'is_active', 'category_code' etc. If you need to use a field that does not correspond to a property in the underlying entity, f.ex. when combining two fields into one you must override the __getFieldValue()__ method and handle that special case there.

[source,java]
----
@Override
public Object getFieldValue(JRField jrField) {
  if (jrField.getName().equals("name_category_code") {
    Entity currentRecord = getCurrentEntity();

    return currentRecord.getString(Store.ITEM_NAME) + " - "
             + currentRecord.getAsString(Store.ITEM_CATEGORY_CODE);
  }

  return super.getFieldValue(jrField);
}
----

The way you view the report is just like in the jdbc report example above except you use the __viewReport()__ method instead of __viewJdbcReport()__.

=== Examples

* <<{dir-tutorials}/empdept.adoc#_application_ui_layer, EmpDept UI layer>>