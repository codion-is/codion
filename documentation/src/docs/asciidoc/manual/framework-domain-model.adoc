= Domain Model
:dir-tutorials: ../tutorials
:dir-source: ../../../../../demos/manual/src/main/java
:dir-petstore-source: ../../../../../demos/petstore/src/main/java
:dir-world-source: ../../../../../demos/world/src/main/java
:dir-world-resources: ../../../../../demos/world/src/main/resources
:dir-chinook-source: ../../../../../demos/chinook/src/main/java
:url-javadoc: link:../api

The domain model in Codion is based on the {url-javadoc}/is/codion/framework/domain/entity/Entity.html[Entity] interface, which represents a row in a table. Defining the domain model involves creating constants representing the domain ({url-javadoc}/is/codion/framework/domain/DomainType.html[DomainType]), the table ({url-javadoc}/is/codion/framework/domain/entity/EntityType.html[EntityType]), columns ({url-javadoc}/is/codion/framework/domain/entity/Attribute.html[Attribute]) and foreign keys ({url-javadoc}/is/codion/framework/domain/entity/ForeignKey.html[ForeignKey]). These constants represent the domain API and are used when referring to tables, columns or foreign keys. These are wrapped in an interface denoting the entity type, for a convenient namespace.

[source,java,indent=0]
----
include::{dir-source}/is/codion/framework/demos/manual/store/minimal/Introduction.java[tags=storeApi]
----

The domain model is then implemented by extending the {url-javadoc}/is/codion/framework/domain/DefaultDomain.html[DefaultDomain] class, which we use to define the domain entities and their properties based on the aformentioned API constants.

[source,java,indent=0]
----
include::{dir-source}/is/codion/framework/demos/manual/store/minimal/Introduction.java[tags=storeImpl]
----

The domain model provides a {url-javadoc}/is/codion/framework/domain/entity/Entities.html[Entities] instance via {url-javadoc}/is/codion/framework/domain/Domain.html#getEntities--[getEntities()], which serves as a container for the domain entity definitions and as a factory for *Entity* and *Key* instances.

[source,java,indent=0]
----
include::{dir-source}/is/codion/framework/demos/manual/store/minimal/Introduction.java[tags=domainUsage]
----

== Entities

The {url-javadoc}/is/codion/framework/domain/entity/Entity.html[Entity] class is a map like structure, which maps column values to the attribute representing each column. Each table is represented by a EntityType constant with a name unique within the domain.

NOTE: Typically, the *entityType* name contains the underlying table name, but you can use whatever identifying string you want and specify the table name via a *tableName* parameter when defining the entity.

== Attributes

Each column in a table is associated with a {url-javadoc}/is/codion/framework/domain/entity/Attribute.html[Attribute] constant, which has a name and denotes the value type. The {url-javadoc}/is/codion/framework/domain/entity/EntityType.html[EntityType] class provides factory methods for constructing Attribute objects for that entity type.

NOTE: Typically, the *attribute* name is the underlying column name, but as with the *entityType* you can use whatever value you want and specify the column name via the *columnName()* method when instantiating the associated Property.

=== Supported data types

The following data types are supported out of the box:

[cols="1,3"]
|===
|Java type|SQL type

|Integer|java.sql.Types.INTEGER
|Double|java.sql.Types.DOUBLE
|Long|java.sql.Types.BIGINT
|BigDecimal|java.sql.Types.DECIMAL
|LocalDateTime|java.sql.Types.TIMESTAMP
|LocalDate|java.sql.Types.DATE
|LocalTime|java.sql.Types.TIME
|OffsetDateTime|java.sql.Types.TIMESTAMP_WITH_TIMEZONE
|String|java.sql.Types.VARCHAR
|Boolean|java.sql.Types.BOOLEAN
|Character|java.sql.Types.CHAR
|byte[]|java.sql.Types.BLOB
|===

== Foreign keys

Each foreign key of a table is associated with {url-javadoc}/is/codion/framework/domain/entity/ForeignKey.html[ForeignKey] constant, which has a name and specifies which column attributes the foreign key is based on.

=== Examples

A simple foreign key based on a single column.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/api/World.java[tags=foreignKeyCapital]
----

Foreign key based on a composite key.

[source,java]
----
interface Parent {
  EntityType<Entity> TYPE = DOMAIN.entityType("parent");

  Attribute<Integer> ID_1 = TYPE.integerAttribute("id1");
  Attribute<Integer> ID_2 = TYPE.integerAttribute("id2");
}

interface Child {
  EntityType<Entity> TYPE = DOMAIN.entityType("child");

  Attribute<Integer> PARENT_ID_1 = TYPE.integerAttribute("parent_id1");
  Attribute<Integer> PARENT_ID_2 = TYPE.integerAttribute("parent_id2");

  ForeignKey PARENT_FK = TYPE.foreignKey("parent",
          PARENT_ID_1, Parent.ID_1,
          PARENT_ID_2, Parent.ID_2);
}
----

Constant definitions for the World demo (simplified).

[source,java]
----
include::{dir-source}/is/codion/framework/demos/manual/world/domain/World.java[tags=entityTypesAndAttributes]
----

== Properties

Each column is represented by the {url-javadoc}/is/codion/framework/domain/property/Property.html[Property] class or one of its subclasses. The {url-javadoc}/is/codion/framework/domain/property/Properties.html[Properties] class provides factory methods for constructing Property objects and is usually statically imported, as will be assumed in the following examples. Each Property is based on an Attribute or ForeignKey constant.

=== Property

{url-javadoc}/is/codion/framework/domain/property/Property.html[Property] and its subclasses are used to represent entity properties, these can be transient or based on table columns.

=== Primary key

It is recommended that entities have a primary key defined, that is, one or more column properties representing a unique column combination.

The only requirement is that the primary key properties represent a unique column combination for the underlying table, it does not have to correspond to an actual table primary key, although that is of course preferable. The framework does not enforce uniqueness for these properties, so a unique or primary key on the corresponding table columns is strongly recommended.

If no primary key properties are specified the entity is somewhat restricted, it can not be referenced via a foreign key and equals() does not work (since it is based on the primary key). You can still use the *Entity.valuesEqual()* method to check if all values are equal in two entities.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=primaryKey]
----

In case of composite primary keys you create a ColumnProperty and specify the primary key index.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=compositePrimaryKey]
----

=== ColumnProperty

{url-javadoc}/is/codion/framework/domain/property/ColumnProperty.html[ColumnProperty] is used to represent properties that are based on table columns.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=columnProperty]
----

==== Subquery

A ColumnProperty can be used to select a value from a subquery returning a single value. Note that in the example below *country.code* must be available when the query is run, that is, the entity must include that column as a property.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=subqueryProperty]
----

=== BlobProperty

{url-javadoc}/is/codion/framework/domain/property/BlobProperty.html[BlobProperty] is a specific ColumnProperty for the Types.BLOB type which provides lazy loading for BLOB values. Using a standard ColumnProperty with a byte array type works fine, but for lazy loading you have to use BlobProperty.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=blobProperty]
----

[#_foreignkeyproperty]
=== ForeignKeyProperty

{url-javadoc}/is/codion/framework/domain/property/ForeignKeyProperty.html[ForeignKeyProperty] is a property used to represent a foreign key relation.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=foreignKeyPropertyCapital]
----

=== Boolean Properties

For databases supporting *Types.BOOLEAN* you simply use *Properties.columnProperty*.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=booleanProperty]
----

For databases lacking native boolean support we use the *Properties.booleanProperty* method, specifying the underlying type and the true/false values.

[source,java]
----
booleanProperty(Customer.IS_ACTIVE, "Is active", Integer.class, 1, 0)
----

[source,java]
----
booleanProperty(Customer.IS_ACTIVE, "Is active", String.class, "true", "false")
----

[source,java]
----
booleanProperty(Customer.IS_ACTIVE, "Is active", Character.class, 'T', 'F')
----

Note that boolean properties always use the boolean Java type, the framework handles translating to and from the actual column values.

[source,java]
----
entity.put(Customer.IS_ACTIVE, true);

Boolean isActive = entity.get(Customer.IS_ACTIVE);
----

=== ItemProperty

A property based on a list of valid items.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=item]
----

=== DenormalizedViewProperty

An entity can include a property value from an entity referenced via foreign key, by defining a denormalized view property.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=denormalizedViewProperty]
----

=== DenormalizedProperty

{url-javadoc}/is/codion/framework/domain/property/DenormalizedProperty.html[DenormalizedProperty] is used for columns that should automatically get their value from a column in a referenced table. This property automatically gets the value from the attribute in the referenced table when the corresponding reference property value is set.

[source,java]
----
denormalizedProperty(Customer.CITY, Customer.ADDRESS_FK, Address.CITY, "City")
----

NOTE: The property is not kept in sync if the value of the denormalized property is modified in the referenced entity.

[source,java]
----
Entities entities = getEntities();

Entity address = entities.entity(Address.TYPE);
address.put(Address.CITY, "Syracuse");

Entity customer = entities.entity(Customer.TYPE);
customer.put(Customer.ADDRESS_FK, address);

customer.get(Customer.CITY);//returns "Syracuse"

//NB
address.put(Address.CITY, "Canastota");
customer.get(Customer.CITY, still returns "Syracuse"

customer.put(Customer.ADDRESS_FK, address);//set the referenced value again
customer.get(Customer.CITY);//now this returns "Canastota"
----

=== TransientProperty

{url-javadoc}/is/codion/framework/domain/property/TransientProperty.html[TransientProperty] is used to represent a property which is not based on an underlying column, these properties all have a default value of null and can be set and retrieved just like normal properties.

=== DerivedProperty

{url-javadoc}/is/codion/framework/domain/property/DerivedProperty.html[DerivedProperty] is used to represent a transient property which value is derived from one or more properties in the same entity. The value of a derived property is provided via a {url-javadoc}/is/codion/framework/domain/property/DerivedProperty.Provider.html[DerivedProperty.Provider] implementation as shown below.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=derivedProperty]
----

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/api/World.java[tags=derivedPropertyProvider]
----

== Domain

Each entity type is defined by calling {url-javadoc}/is/codion/framework/domain/DefaultDomain.html#define-is.codion.framework.domain.entity.EntityType-is.codion.framework.domain.property.Property.Builder\...-[DefaultDomain.define]. The framework assumes the *entityType* name contains the table name, unless the *tableName* parameter is specified.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=defineCity]
----

=== Examples
* <<{dir-tutorials}/world.adoc#_domain, World domain model>>
* <<{dir-tutorials}/empdept.adoc#_domain, EmpDept domain model>>
* <<{dir-tutorials}/chinook.adoc#_domain, Chinook domain model>>
* <<{dir-tutorials}/petstore.adoc#_domain, Petstore domain model>>

[#_keygenerator]
== KeyGenerator

The framework provides implementations for most commonly used primary key generation strategies, identity column, sequence (with or without trigger) and auto-increment columns. The {url-javadoc}/is/codion/framework/domain/entity/KeyGenerator.html[KeyGenerator] class serves as a factory for {url-javadoc}/is/codion/framework/domain/entity/KeyGenerator.html[KeyGenerator] implementations. Static imports are assumed in the below examples.

=== Identity

Based on identity columns, supported by most DBMSs.

[source,java,indent=0]
----
include::{dir-chinook-source}/is/codion/framework/demos/chinook/domain/impl/ChinookImpl.java[tags=identity]
----

=== Automatic

This assumes the underlying primary key column is either an auto-increment column or is populated from a sequence using a trigger during insert.
For auto-increment columns the **valueSource** parameter should be the table name and for a sequence/trigger it should be the sequence name.

[source,java]
----
//Auto increment column in the 'store.customer' table
.keyGenerator(automatic("store.customer"));

//Trigger and sequence named 'store.customer_seq'
.keyGenerator(automatic("store.customer_seq"));
----

=== Sequence

When sequences are used without triggers the framework can fetch the value from a sequence before insert.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=sequence]
----

=== Queried

The framework can select new primary key values from a query.

[source,java]
----
//Using a query returning the new value
.keyGenerator(queried(
    "select new_id
     from store.id_values
     where table_name = 'store.customer'"));
----

=== Increment

The framework can automatically increment the primary key value by selecting the maximum value and add one, this is very simplistic, not transaction safe and is not recommended for use anywhere but the simplest demos.

[source,java]
----
.keyGenerator(increment("scott.emp", "empno"))
----

=== Custom

You can provide a custom key generator strategy by implementing a {url-javadoc}/is/codion/framework/domain/entity/KeyGenerator.html[KeyGenerator].

[source,java,indent=0]
----
include::{dir-source}/is/codion/framework/demos/manual/store/domain/Store.java[tags=keyGenerator]
----

== StringFactory

The {url-javadoc}/is/codion/framework/domain/entity/StringFactory.html[StringFactory] class provides a builder for Function<Entity, String> which provides the *toString()* implementations for entities. This value is used wherever entities are displayed, for example in a ComboBox or as foreign key values in table views.

[source,java,indent=0]
----
include::{dir-source}/is/codion/framework/demos/manual/store/domain/Store.java[tags=address]
----

For more complex toString() implementations you can implement a custom *Function<Entity, String>*.

[source,java,indent=0]
----
include::{dir-source}/is/codion/framework/demos/manual/store/domain/Store.java[tags=customerStringFactory]
----

[source,java,indent=0]
----
include::{dir-source}/is/codion/framework/demos/manual/store/domain/Store.java[tags=toString]
----

== ColorProvider

{url-javadoc}/is/codion/framework/domain/entity/ColorProvider.html[ColorProvider] is used to provide colors for entity properties, used as background color in table cells for example.

The framework supports String color definitions, in a format recognized by *java.awt.Color.decode()*, like the one below, in case you don't want a dependency on *java.awt.Color* in the domain model.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/api/World.java[tags=colorProvider]
----

== Validation

Custom validation of Entities is performed by implementing a {url-javadoc}/is/codion/framework/domain/entity/EntityValidator.html[EntityValidator].

The *DefaultEntityValidator* implementation provides basic range and null validation and can be extended to provide further validations. Note that validation is performed quite often, so it should not perform expensive operations. Validation requiring database access for example belongs in the application model or ui.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/api/World.java[tags=validator]
----

== Examples

* <<{dir-tutorials}/empdept.adoc#_domain, EmpDept domain model>>
* <<{dir-tutorials}/chinook.adoc#_domain, Chinook domain model>>
* <<{dir-tutorials}/petstore.adoc#_domain, Petstore domain model>>

== Custom data types

When using a custom data type you must specify the *columnClass* of a ColumnProperty and
provide a {url-javadoc}/is/codion/framework/domain/property/ColumnProperty.ValueConverter.html[ValueConverter] implementation.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/api/World.java[tags=customType]
----

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/api/World.java[tags=customTypeClass]
----

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=columnClass]
----

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/WorldImpl.java[tags=converter]
----

This custom type must be serializable for use in an application using the RMI connection.

When using the HTTP connection in an application using a custom data type, you must implement a {url-javadoc}/is/codion/plugin/jackson/json/domain/EntityObjectMapperFactory.html[EntityObjectMapperFactory], providing a {url-javadoc}/is/codion/plugin/jackson/json/domain/EntityObjectMapper.html[EntityObjectMapper] containing a serializer/deserializer for the custom types.

[source,java,indent=0]
----
include::{dir-world-source}/is/codion/framework/demos/world/domain/api/WorldObjectMapperFactory.java[tags=customSerializer]
----

This *EntityObjectMapperFactory* must be exposed to the ServiceLoader.

_src/main/java/module-info.java_

[source]
----
include::{dir-world-source}/module-info.java[tag=customSerializer]
----

See <<{dir-tutorials}/world.adoc#_domain, World domain model>>

== Entities in action

Using the Entity class is rather straight forward.

[source,java,indent=0]
----
include::{dir-petstore-source}/is/codion/framework/demos/petstore/manual/EntitiesInAction.java[tags=entitiesInAction]
----

== Unit Testing

=== Introduction

To unit test the CRUD operations on the domain model extend {url-javadoc}/is/codion/framework/domain/entity/test/EntityTestUnit.html[EntityTestUnit].

The unit tests are run within a single transaction which is rolled back after the test finishes, so these tests are pretty much guaranteed to leave no junk data behind.

=== EntityTestUnit

The following methods all have default implementations which are based on randomly created property values, based on the constraints set in the domain model, override if the default ones are not working.

* {url-javadoc}/is/codion/framework/domain/entity/test/EntityTestUnit.html#initializeReferenceEntity-is.codion.framework.domain.entity.EntityType-java.util.Map-[initializeReferenceEntity] should return an instance of the given entity type to use for a foreign key reference required for inserting the entity being tested.
* {url-javadoc}/is/codion/framework/domain/entity/test/EntityTestUnit.html#initializeTestEntity-is.codion.framework.domain.entity.EntityType-java.util.Map-[initializeTestEntity] should return an entity to use as basis for the unit test, that is, the entity that should be inserted, selected, updated and finally deleted.
* {url-javadoc}/is/codion/framework/domain/entity/test/EntityTestUnit.html#modifyEntity-is.codion.framework.domain.entity.Entity-java.util.Map-[modifyEntity] should simply leave the entity in a modified state so that it can be used for update test, since the database layer throws an exception if an unmodified entity is updated. If *modifyEntity* returns an unmodified entity, the update test is skipped.

To run the full CRUD test for a domain entity you need to call the *test(EntityType entityType)* method with the entity type as parameter. You can either create a single *testDomain()* method and call the *test* method in turn for each entityType or create a *entityName* method for each domain entity, as we do in the example below.

[source,java]
----
include::{dir-source}/is/codion/framework/demos/manual/store/domain/StoreTest.java[tags=storeTest]
----

=== Examples

* <<{dir-tutorials}/empdept.adoc#_domain_unit_test, EmpDept domain model test>>
* <<{dir-tutorials}/chinook.adoc#_domain_unit_test, Chinook domain model test>>
* <<{dir-tutorials}/petstore.adoc#_domain_unit_test, Petstore domain model test>>