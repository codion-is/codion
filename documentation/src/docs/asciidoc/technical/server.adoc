[#_entity_server]
= Server
:dir-tutorials: ../tutorials
:dir-source: ../../../../../demos/server
:dir-manual-source: ../../../../../demos/manual/src/main/java
:url-javadoc: link:../api

The Codion server provides RMI and HTTP connection options to clients.

== Features

* Firewall friendly RMI; uses one way communication without callbacks, uses two ports, one for the RMI Registry and one for client connections
* Integrated web server for serving HTTP client connections, based on https://github.com/javalin/javalin[Javalin] and https://github.com/eclipse/jetty.project[Jetty]
* All user authentication left to the database by default
* Comprehensive administration and monitoring facilities via the <<server-monitor.adoc#_server_monitor, ServerMonitor>>
* Featherweight server with moderate memory and CPU usage

== Security

Here's a great overview of RMI security risks and mitigations.

https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf[Attacking Java RMI via SSRF]

[#_authentication]
=== Authentication

The Codion server does not perform any user authentication by default, it leaves that up the underlying database.
An authentication layer can be added by implementing an {url-javadoc}{common-rmi}/is/codion/common/rmi/server/Authenticator.html[Authenticator] and registering it with the ServiceLoader.

==== Authenticator examples

<<{dir-tutorials}/chinook/chinook.adoc#_chinookauthenticator, ChinookAuthenticator>>

=== RMI SSL encryption

To enable SSL encryption between client and server, create a keystore and truststore pair and set the following system properties.

==== Server side

[source]
----
codion.server.connection.sslEnabled=true # <1>
javax.net.ssl.keyStore=keystore.jks
javax.net.ssl.keyStorePassword=password
----

<1> This property is 'true' by default, included here for completeness's sake

==== Client side

[source]
----
codion.client.trustStore=truststore.jks
codion.client.trustStorePassword=password
----

=== Class loading

No dynamic class loading is required.

[#_serialization_filtering]
=== Serialization filtering

See https://docs.oracle.com/en/java/javase/23/core/java-serialization-filters.html[Java Serialization Filters] and https://openjdk.org/jeps/290[JEP 290: Filter Incoming Serialization Data].

The framework provides a way to configure a https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/ObjectInputFilter.html[ObjectInputFilter] for deserialization, by specifying a {url-javadoc}{common-rmi}/is/codion/common/rmi/server/ObjectInputFilterFactory.html[ObjectInputFilterFactory] implementation class with the following system property.

[source]
----
codion.server.objectInputFilterFactory=\
    my.serialization.filter.MyObjectInputFilterFactory
----

IMPORTANT: By default, an `ObjectInputFilterFactory` is **required** for the server to start. If no filter factory is configured, the server will throw an exception on startup. This is a security measure to prevent accidental deployment without deserialization filtering.

To explicitly disable this requirement (not recommended for production), set:

[source]
----
codion.server.objectInputFilterFactoryRequired=false
----

==== Pattern filter

To use the built-in pattern based serialization filter, set the following system property.

[source]
----
codion.server.objectInputFilterFactory=\
    is.codion.common.rmi.server.SerializationFilterFactory
----

To use serialization filter patterns specified in a string, set the following system property.

[source]
----
codion.server.serialization.filter.pattern=pattern1;pattern2
----

This is equivalent to setting the following:

[source]
----
jdk.serialFilter=pattern1;pattern2
----

To use the serialization pattern filter based on patterns in a file, set the following system property.

The file may contain all the patterns in a single line, using the ; delimiter or one pattern per line, without a delimiter. Lines starting with '#' are skipped as comments.

[source]
----
codion.server.serialization.filter.patternFile=config/patterns.txt
----

----
codion.server.serialization.filter.patternFile=classpath:patterns.txt
----

A list of deserialized classes can be created during a server dry-run by adding the following system property.
The file containing all classes deserialized during the run is written to disk on server shutdown.

[source]
----
codion.server.serialization.filter.dryRunFile=deserialized.txt
----

.Example whitelist
[%collapsible]
====
[source]
----
include::{dir-source}/src/main/config/serialization-whitelist.txt[]
----
====

==== Resource exhaustion limits

The pattern-based serialization filter supports https://openjdk.org/jeps/290[JEP 290]  resource limits to prevent resource exhaustion attacks during deserialization.
These limits are enforced **during** deserialization, before objects are fully materialized in memory.

The following system properties configure the resource limits (with their default values):

[source]
----
codion.server.serialization.filter.maxBytes=10485760    # Maximum stream size: 10 MB
codion.server.serialization.filter.maxArray=100000      # Maximum array length: 100,000 elements
codion.server.serialization.filter.maxDepth=100         # Maximum object graph depth: 100 levels
codion.server.serialization.filter.maxRefs=1000000      # Maximum internal references: 1,000,000 refs
----

These limits are automatically prepended to the serialization filter patterns.
For example, with a pattern file containing class names, the effective filter becomes:

[source]
----
maxbytes=10485760;maxarray=100000;maxdepth=100;maxrefs=1000000;java.lang.String;is.codion.**;!*
----

**Important**: These limits provide the primary defense against resource exhaustion attacks.
Application-level validation (such as User credential length limits) cannot prevent memory allocation during deserialization,
making these https://openjdk.org/jeps/290[JEP 290] limits essential for security.

[#_http_connections]
== HTTP

Codion provides HTTP-based connections as an alternative to RMI, accessible via the {url-javadoc}{framework-db-http}/is/codion/framework/db/http/HttpEntityConnection.html[HttpEntityConnection] interface. The framework supports two distinct HTTP connection types, each with different serialization strategies optimized for different scenarios.

=== Connection Types

==== Serialization-based Connection

The default HTTP connection uses Java serialization for all communication:

* **Performance**: More efficient for complex object graphs with automatic deduplication
* **Memory**: Lower memory footprint due to object reference handling
* **Security**: Requires proper deserialization filtering (see <<#_serialization_filtering, Serialization filtering>>)
* **Configuration**: Server-side enabled via `codion.server.http.serialization=true` (default: `false`)

The serialization-based connection is ideal for trusted networks and scenarios where performance is critical.

==== JSON-based Connection

The JSON connection provides a more security-conscious approach:

* **Security**: Eliminates server-side deserialization vulnerabilities by using JSON for incoming requests
* **Transparency**: Human-readable request/response format for debugging
* **Compatibility**: Works with non-Java clients (when using JSON throughout)
* **Configuration**: Server-side enabled via `codion.server.http.json=true` (default: `true`)

The JSON connection uses a **hybrid serialization strategy**:

[cols="2,3,2", options="header"]
|===
|Operation|Request|Response
|CRUD operations|JSON|JSON
|Function parameters|JSON|Java serialization
|Function results|N/A|Java serialization
|Procedure parameters|JSON|N/A
|Report parameters|JSON|Java serialization
|Report results|N/A|Java serialization
|Entities instance|N/A|Java serialization
|===

IMPORTANT: The hybrid approach protects the server from deserialization attacks (the primary security concern) while maintaining compatibility with complex return types like `JasperPrint` that don't support JSON serialization. The client deserializing responses from its chosen server is not a security concern.

=== Choosing a Connection Type

**Use serialization-based connections when:**

* Operating in a trusted network environment
* Performance and memory efficiency are priorities
* You have proper deserialization filtering configured
* All clients are Java-based

**Use JSON-based connections when:**

* Security is the primary concern (avoiding server-side deserialization)
* Operating in less trusted environments
* You want human-readable request/response payloads
* You need non-Java client compatibility (with custom JSON handling)

=== JSON Connection Requirements

When using the JSON connection with functions, procedures, or reports that have parameters, you must register parameter types with the {url-javadoc}{framework-json-domain}/is/codion/framework/json/domain/EntityObjectMapper.html[EntityObjectMapper]. This is required because Jackson needs target types to deserialize JSON, and generic type parameters are erased at runtime.

See the manual section on <<../manual/framework-domain-procedures-functions.adoc#_entityobjectmapperfactory, HTTP/JSON Serialization>> for details on registering parameter types via {url-javadoc}{framework-json-domain}/is/codion/framework/json/domain/EntityObjectMapperFactory.html[EntityObjectMapperFactory].

=== Server Configuration

Enable or disable connection types on the server:

[source]
----
codion.server.http.serialization=false  # Default: false
codion.server.http.json=true            # Default: true
----

Both can be enabled simultaneously, allowing clients to choose their preferred connection type.

=== Client Configuration

Clients select their connection type via configuration:

[source]
----
codion.client.http.json=true   # Default: true (JSON), false for serialization
----

== Configuration

=== Example configuration file

[source]
----
include::{dir-source}/src/main/config/h2_embedded.config[]
----

== Code examples

Absolute bare-bones examples of how to run the EntityServer and connect to it.

=== RMI

[source]
----
include::{dir-manual-source}/is/codion/manual/store/ClientServer.java[tags=runServer]
----

=== HTTP

[source]
----
include::{dir-manual-source}/is/codion/manual/store/ClientServer.java[tags=runServerWithHttp]
----